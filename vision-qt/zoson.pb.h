// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: zoson.proto

#ifndef PROTOBUF_zoson_2eproto__INCLUDED
#define PROTOBUF_zoson_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_zoson_2eproto();
void protobuf_AssignDesc_zoson_2eproto();
void protobuf_ShutdownFile_zoson_2eproto();

class TestProto;
class DetectorParameter;
class DetectInput;
class DetectOutput;
class Result;
class CommuParameter;
class ClassMaps;
class ClassMap;
class Cookie;
class Bytetranfer;
class VLayerInfos;
class VLayerInfo;
class VFeatureMap;
class VImage;
class VReqDeconv;
class VSetting;
class VResponse;
class VAll;
class VReqFeature;
class VReqWeight;
class VState;

enum DetectInput_Format {
  DetectInput_Format_JPG = 0,
  DetectInput_Format_PNG = 1,
  DetectInput_Format_RGB = 2,
  DetectInput_Format_YOV_420 = 3,
  DetectInput_Format_YOV_422 = 4
};
bool DetectInput_Format_IsValid(int value);
const DetectInput_Format DetectInput_Format_Format_MIN = DetectInput_Format_JPG;
const DetectInput_Format DetectInput_Format_Format_MAX = DetectInput_Format_YOV_422;
const int DetectInput_Format_Format_ARRAYSIZE = DetectInput_Format_Format_MAX + 1;

const ::google::protobuf::EnumDescriptor* DetectInput_Format_descriptor();
inline const ::std::string& DetectInput_Format_Name(DetectInput_Format value) {
  return ::google::protobuf::internal::NameOfEnum(
    DetectInput_Format_descriptor(), value);
}
inline bool DetectInput_Format_Parse(
    const ::std::string& name, DetectInput_Format* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DetectInput_Format>(
    DetectInput_Format_descriptor(), name, value);
}
enum CommuParameter_Type {
  CommuParameter_Type_LOC = 0,
  CommuParameter_Type_IPC = 1,
  CommuParameter_Type_TCP = 3,
  CommuParameter_Type_RTMP = 4
};
bool CommuParameter_Type_IsValid(int value);
const CommuParameter_Type CommuParameter_Type_Type_MIN = CommuParameter_Type_LOC;
const CommuParameter_Type CommuParameter_Type_Type_MAX = CommuParameter_Type_RTMP;
const int CommuParameter_Type_Type_ARRAYSIZE = CommuParameter_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* CommuParameter_Type_descriptor();
inline const ::std::string& CommuParameter_Type_Name(CommuParameter_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    CommuParameter_Type_descriptor(), value);
}
inline bool CommuParameter_Type_Parse(
    const ::std::string& name, CommuParameter_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CommuParameter_Type>(
    CommuParameter_Type_descriptor(), name, value);
}
enum VResponse_Type {
  VResponse_Type_WEIGHT = 1,
  VResponse_Type_FEATUREMAP = 2,
  VResponse_Type_LAYERINFOS = 3,
  VResponse_Type_INPUT = 4,
  VResponse_Type_DECONV = 5,
  VResponse_Type_ALL = 6,
  VResponse_Type_STATE = 7,
  VResponse_Type_SETTING = 8
};
bool VResponse_Type_IsValid(int value);
const VResponse_Type VResponse_Type_Type_MIN = VResponse_Type_WEIGHT;
const VResponse_Type VResponse_Type_Type_MAX = VResponse_Type_SETTING;
const int VResponse_Type_Type_ARRAYSIZE = VResponse_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* VResponse_Type_descriptor();
inline const ::std::string& VResponse_Type_Name(VResponse_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    VResponse_Type_descriptor(), value);
}
inline bool VResponse_Type_Parse(
    const ::std::string& name, VResponse_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VResponse_Type>(
    VResponse_Type_descriptor(), name, value);
}
// ===================================================================

class TestProto : public ::google::protobuf::Message {
 public:
  TestProto();
  virtual ~TestProto();

  TestProto(const TestProto& from);

  inline TestProto& operator=(const TestProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TestProto& default_instance();

  void Swap(TestProto* other);

  // implements Message ----------------------------------------------

  TestProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TestProto& from);
  void MergeFrom(const TestProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 clazz_num = 1;
  inline bool has_clazz_num() const;
  inline void clear_clazz_num();
  static const int kClazzNumFieldNumber = 1;
  inline ::google::protobuf::int32 clazz_num() const;
  inline void set_clazz_num(::google::protobuf::int32 value);

  // repeated int32 dim = 2;
  inline int dim_size() const;
  inline void clear_dim();
  static const int kDimFieldNumber = 2;
  inline ::google::protobuf::int32 dim(int index) const;
  inline void set_dim(int index, ::google::protobuf::int32 value);
  inline void add_dim(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      dim() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_dim();

  // @@protoc_insertion_point(class_scope:TestProto)
 private:
  inline void set_has_clazz_num();
  inline void clear_has_clazz_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > dim_;
  ::google::protobuf::int32 clazz_num_;
  friend void  protobuf_AddDesc_zoson_2eproto();
  friend void protobuf_AssignDesc_zoson_2eproto();
  friend void protobuf_ShutdownFile_zoson_2eproto();

  void InitAsDefaultInstance();
  static TestProto* default_instance_;
};
// -------------------------------------------------------------------

class DetectorParameter : public ::google::protobuf::Message {
 public:
  DetectorParameter();
  virtual ~DetectorParameter();

  DetectorParameter(const DetectorParameter& from);

  inline DetectorParameter& operator=(const DetectorParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DetectorParameter& default_instance();

  void Swap(DetectorParameter* other);

  // implements Message ----------------------------------------------

  DetectorParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DetectorParameter& from);
  void MergeFrom(const DetectorParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string model = 2;
  inline bool has_model() const;
  inline void clear_model();
  static const int kModelFieldNumber = 2;
  inline const ::std::string& model() const;
  inline void set_model(const ::std::string& value);
  inline void set_model(const char* value);
  inline void set_model(const char* value, size_t size);
  inline ::std::string* mutable_model();
  inline ::std::string* release_model();
  inline void set_allocated_model(::std::string* model);

  // required string weight = 3;
  inline bool has_weight() const;
  inline void clear_weight();
  static const int kWeightFieldNumber = 3;
  inline const ::std::string& weight() const;
  inline void set_weight(const ::std::string& value);
  inline void set_weight(const char* value);
  inline void set_weight(const char* value, size_t size);
  inline ::std::string* mutable_weight();
  inline ::std::string* release_weight();
  inline void set_allocated_weight(::std::string* weight);

  // optional bool use_gpu = 4 [default = true];
  inline bool has_use_gpu() const;
  inline void clear_use_gpu();
  static const int kUseGpuFieldNumber = 4;
  inline bool use_gpu() const;
  inline void set_use_gpu(bool value);

  // optional bool do_vis = 5 [default = false];
  inline bool has_do_vis() const;
  inline void clear_do_vis();
  static const int kDoVisFieldNumber = 5;
  inline bool do_vis() const;
  inline void set_do_vis(bool value);

  // optional int32 fq_vis = 6 [default = 10];
  inline bool has_fq_vis() const;
  inline void clear_fq_vis();
  static const int kFqVisFieldNumber = 6;
  inline ::google::protobuf::int32 fq_vis() const;
  inline void set_fq_vis(::google::protobuf::int32 value);

  // optional float threshold = 7 [default = 0.5];
  inline bool has_threshold() const;
  inline void clear_threshold();
  static const int kThresholdFieldNumber = 7;
  inline float threshold() const;
  inline void set_threshold(float value);

  // optional bool shared = 8 [default = false];
  inline bool has_shared() const;
  inline void clear_shared();
  static const int kSharedFieldNumber = 8;
  inline bool shared() const;
  inline void set_shared(bool value);

  // optional bool istrain = 9 [default = false];
  inline bool has_istrain() const;
  inline void clear_istrain();
  static const int kIstrainFieldNumber = 9;
  inline bool istrain() const;
  inline void set_istrain(bool value);

  // optional string solver = 10;
  inline bool has_solver() const;
  inline void clear_solver();
  static const int kSolverFieldNumber = 10;
  inline const ::std::string& solver() const;
  inline void set_solver(const ::std::string& value);
  inline void set_solver(const char* value);
  inline void set_solver(const char* value, size_t size);
  inline ::std::string* mutable_solver();
  inline ::std::string* release_solver();
  inline void set_allocated_solver(::std::string* solver);

  // optional string snapshot = 11;
  inline bool has_snapshot() const;
  inline void clear_snapshot();
  static const int kSnapshotFieldNumber = 11;
  inline const ::std::string& snapshot() const;
  inline void set_snapshot(const ::std::string& value);
  inline void set_snapshot(const char* value);
  inline void set_snapshot(const char* value, size_t size);
  inline ::std::string* mutable_snapshot();
  inline ::std::string* release_snapshot();
  inline void set_allocated_snapshot(::std::string* snapshot);

  // @@protoc_insertion_point(class_scope:DetectorParameter)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_model();
  inline void clear_has_model();
  inline void set_has_weight();
  inline void clear_has_weight();
  inline void set_has_use_gpu();
  inline void clear_has_use_gpu();
  inline void set_has_do_vis();
  inline void clear_has_do_vis();
  inline void set_has_fq_vis();
  inline void clear_has_fq_vis();
  inline void set_has_threshold();
  inline void clear_has_threshold();
  inline void set_has_shared();
  inline void clear_has_shared();
  inline void set_has_istrain();
  inline void clear_has_istrain();
  inline void set_has_solver();
  inline void clear_has_solver();
  inline void set_has_snapshot();
  inline void clear_has_snapshot();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* model_;
  ::std::string* weight_;
  ::google::protobuf::int32 fq_vis_;
  bool use_gpu_;
  bool do_vis_;
  bool shared_;
  bool istrain_;
  ::std::string* solver_;
  ::std::string* snapshot_;
  float threshold_;
  friend void  protobuf_AddDesc_zoson_2eproto();
  friend void protobuf_AssignDesc_zoson_2eproto();
  friend void protobuf_ShutdownFile_zoson_2eproto();

  void InitAsDefaultInstance();
  static DetectorParameter* default_instance_;
};
// -------------------------------------------------------------------

class DetectInput : public ::google::protobuf::Message {
 public:
  DetectInput();
  virtual ~DetectInput();

  DetectInput(const DetectInput& from);

  inline DetectInput& operator=(const DetectInput& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DetectInput& default_instance();

  void Swap(DetectInput* other);

  // implements Message ----------------------------------------------

  DetectInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DetectInput& from);
  void MergeFrom(const DetectInput& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef DetectInput_Format Format;
  static const Format JPG = DetectInput_Format_JPG;
  static const Format PNG = DetectInput_Format_PNG;
  static const Format RGB = DetectInput_Format_RGB;
  static const Format YOV_420 = DetectInput_Format_YOV_420;
  static const Format YOV_422 = DetectInput_Format_YOV_422;
  static inline bool Format_IsValid(int value) {
    return DetectInput_Format_IsValid(value);
  }
  static const Format Format_MIN =
    DetectInput_Format_Format_MIN;
  static const Format Format_MAX =
    DetectInput_Format_Format_MAX;
  static const int Format_ARRAYSIZE =
    DetectInput_Format_Format_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Format_descriptor() {
    return DetectInput_Format_descriptor();
  }
  static inline const ::std::string& Format_Name(Format value) {
    return DetectInput_Format_Name(value);
  }
  static inline bool Format_Parse(const ::std::string& name,
      Format* value) {
    return DetectInput_Format_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int32 width = 2;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 2;
  inline ::google::protobuf::int32 width() const;
  inline void set_width(::google::protobuf::int32 value);

  // required int32 height = 3;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 3;
  inline ::google::protobuf::int32 height() const;
  inline void set_height(::google::protobuf::int32 value);

  // required bytes data = 4;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 4;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:DetectInput)
 private:
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 height_;
  ::std::string* data_;
  friend void  protobuf_AddDesc_zoson_2eproto();
  friend void protobuf_AssignDesc_zoson_2eproto();
  friend void protobuf_ShutdownFile_zoson_2eproto();

  void InitAsDefaultInstance();
  static DetectInput* default_instance_;
};
// -------------------------------------------------------------------

class DetectOutput : public ::google::protobuf::Message {
 public:
  DetectOutput();
  virtual ~DetectOutput();

  DetectOutput(const DetectOutput& from);

  inline DetectOutput& operator=(const DetectOutput& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DetectOutput& default_instance();

  void Swap(DetectOutput* other);

  // implements Message ----------------------------------------------

  DetectOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DetectOutput& from);
  void MergeFrom(const DetectOutput& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Result results = 1;
  inline int results_size() const;
  inline void clear_results();
  static const int kResultsFieldNumber = 1;
  inline const ::Result& results(int index) const;
  inline ::Result* mutable_results(int index);
  inline ::Result* add_results();
  inline const ::google::protobuf::RepeatedPtrField< ::Result >&
      results() const;
  inline ::google::protobuf::RepeatedPtrField< ::Result >*
      mutable_results();

  // @@protoc_insertion_point(class_scope:DetectOutput)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Result > results_;
  friend void  protobuf_AddDesc_zoson_2eproto();
  friend void protobuf_AssignDesc_zoson_2eproto();
  friend void protobuf_ShutdownFile_zoson_2eproto();

  void InitAsDefaultInstance();
  static DetectOutput* default_instance_;
};
// -------------------------------------------------------------------

class Result : public ::google::protobuf::Message {
 public:
  Result();
  virtual ~Result();

  Result(const Result& from);

  inline Result& operator=(const Result& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Result& default_instance();

  void Swap(Result* other);

  // implements Message ----------------------------------------------

  Result* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Result& from);
  void MergeFrom(const Result& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float xmin = 1;
  inline bool has_xmin() const;
  inline void clear_xmin();
  static const int kXminFieldNumber = 1;
  inline float xmin() const;
  inline void set_xmin(float value);

  // required float ymin = 2;
  inline bool has_ymin() const;
  inline void clear_ymin();
  static const int kYminFieldNumber = 2;
  inline float ymin() const;
  inline void set_ymin(float value);

  // required float xmax = 3;
  inline bool has_xmax() const;
  inline void clear_xmax();
  static const int kXmaxFieldNumber = 3;
  inline float xmax() const;
  inline void set_xmax(float value);

  // required float ymax = 4;
  inline bool has_ymax() const;
  inline void clear_ymax();
  static const int kYmaxFieldNumber = 4;
  inline float ymax() const;
  inline void set_ymax(float value);

  // required int32 clazz = 5;
  inline bool has_clazz() const;
  inline void clear_clazz();
  static const int kClazzFieldNumber = 5;
  inline ::google::protobuf::int32 clazz() const;
  inline void set_clazz(::google::protobuf::int32 value);

  // required float score = 6;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 6;
  inline float score() const;
  inline void set_score(float value);

  // @@protoc_insertion_point(class_scope:Result)
 private:
  inline void set_has_xmin();
  inline void clear_has_xmin();
  inline void set_has_ymin();
  inline void clear_has_ymin();
  inline void set_has_xmax();
  inline void clear_has_xmax();
  inline void set_has_ymax();
  inline void clear_has_ymax();
  inline void set_has_clazz();
  inline void clear_has_clazz();
  inline void set_has_score();
  inline void clear_has_score();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float xmin_;
  float ymin_;
  float xmax_;
  float ymax_;
  ::google::protobuf::int32 clazz_;
  float score_;
  friend void  protobuf_AddDesc_zoson_2eproto();
  friend void protobuf_AssignDesc_zoson_2eproto();
  friend void protobuf_ShutdownFile_zoson_2eproto();

  void InitAsDefaultInstance();
  static Result* default_instance_;
};
// -------------------------------------------------------------------

class CommuParameter : public ::google::protobuf::Message {
 public:
  CommuParameter();
  virtual ~CommuParameter();

  CommuParameter(const CommuParameter& from);

  inline CommuParameter& operator=(const CommuParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommuParameter& default_instance();

  void Swap(CommuParameter* other);

  // implements Message ----------------------------------------------

  CommuParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommuParameter& from);
  void MergeFrom(const CommuParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CommuParameter_Type Type;
  static const Type LOC = CommuParameter_Type_LOC;
  static const Type IPC = CommuParameter_Type_IPC;
  static const Type TCP = CommuParameter_Type_TCP;
  static const Type RTMP = CommuParameter_Type_RTMP;
  static inline bool Type_IsValid(int value) {
    return CommuParameter_Type_IsValid(value);
  }
  static const Type Type_MIN =
    CommuParameter_Type_Type_MIN;
  static const Type Type_MAX =
    CommuParameter_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    CommuParameter_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return CommuParameter_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return CommuParameter_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return CommuParameter_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string address = 1 [default = "localhost"];
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 1;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const char* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  inline void set_allocated_address(::std::string* address);

  // optional int32 port = 2 [default = 10086];
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // optional string client_name = 3 [default = "web"];
  inline bool has_client_name() const;
  inline void clear_client_name();
  static const int kClientNameFieldNumber = 3;
  inline const ::std::string& client_name() const;
  inline void set_client_name(const ::std::string& value);
  inline void set_client_name(const char* value);
  inline void set_client_name(const char* value, size_t size);
  inline ::std::string* mutable_client_name();
  inline ::std::string* release_client_name();
  inline void set_allocated_client_name(::std::string* client_name);

  // optional .CommuParameter.Type type = 4 [default = LOC];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline ::CommuParameter_Type type() const;
  inline void set_type(::CommuParameter_Type value);

  // @@protoc_insertion_point(class_scope:CommuParameter)
 private:
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_client_name();
  inline void clear_has_client_name();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  static ::std::string* _default_address_;
  ::std::string* address_;
  static ::std::string* _default_client_name_;
  ::std::string* client_name_;
  ::google::protobuf::int32 port_;
  int type_;
  friend void  protobuf_AddDesc_zoson_2eproto();
  friend void protobuf_AssignDesc_zoson_2eproto();
  friend void protobuf_ShutdownFile_zoson_2eproto();

  void InitAsDefaultInstance();
  static CommuParameter* default_instance_;
};
// -------------------------------------------------------------------

class ClassMaps : public ::google::protobuf::Message {
 public:
  ClassMaps();
  virtual ~ClassMaps();

  ClassMaps(const ClassMaps& from);

  inline ClassMaps& operator=(const ClassMaps& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClassMaps& default_instance();

  void Swap(ClassMaps* other);

  // implements Message ----------------------------------------------

  ClassMaps* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClassMaps& from);
  void MergeFrom(const ClassMaps& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ClassMap item = 1;
  inline int item_size() const;
  inline void clear_item();
  static const int kItemFieldNumber = 1;
  inline const ::ClassMap& item(int index) const;
  inline ::ClassMap* mutable_item(int index);
  inline ::ClassMap* add_item();
  inline const ::google::protobuf::RepeatedPtrField< ::ClassMap >&
      item() const;
  inline ::google::protobuf::RepeatedPtrField< ::ClassMap >*
      mutable_item();

  // @@protoc_insertion_point(class_scope:ClassMaps)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ClassMap > item_;
  friend void  protobuf_AddDesc_zoson_2eproto();
  friend void protobuf_AssignDesc_zoson_2eproto();
  friend void protobuf_ShutdownFile_zoson_2eproto();

  void InitAsDefaultInstance();
  static ClassMaps* default_instance_;
};
// -------------------------------------------------------------------

class ClassMap : public ::google::protobuf::Message {
 public:
  ClassMap();
  virtual ~ClassMap();

  ClassMap(const ClassMap& from);

  inline ClassMap& operator=(const ClassMap& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClassMap& default_instance();

  void Swap(ClassMap* other);

  // implements Message ----------------------------------------------

  ClassMap* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClassMap& from);
  void MergeFrom(const ClassMap& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required int32 label = 2;
  inline bool has_label() const;
  inline void clear_label();
  static const int kLabelFieldNumber = 2;
  inline ::google::protobuf::int32 label() const;
  inline void set_label(::google::protobuf::int32 value);

  // required string display_name = 3;
  inline bool has_display_name() const;
  inline void clear_display_name();
  static const int kDisplayNameFieldNumber = 3;
  inline const ::std::string& display_name() const;
  inline void set_display_name(const ::std::string& value);
  inline void set_display_name(const char* value);
  inline void set_display_name(const char* value, size_t size);
  inline ::std::string* mutable_display_name();
  inline ::std::string* release_display_name();
  inline void set_allocated_display_name(::std::string* display_name);

  // @@protoc_insertion_point(class_scope:ClassMap)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_label();
  inline void clear_has_label();
  inline void set_has_display_name();
  inline void clear_has_display_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* display_name_;
  ::google::protobuf::int32 label_;
  friend void  protobuf_AddDesc_zoson_2eproto();
  friend void protobuf_AssignDesc_zoson_2eproto();
  friend void protobuf_ShutdownFile_zoson_2eproto();

  void InitAsDefaultInstance();
  static ClassMap* default_instance_;
};
// -------------------------------------------------------------------

class Cookie : public ::google::protobuf::Message {
 public:
  Cookie();
  virtual ~Cookie();

  Cookie(const Cookie& from);

  inline Cookie& operator=(const Cookie& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Cookie& default_instance();

  void Swap(Cookie* other);

  // implements Message ----------------------------------------------

  Cookie* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Cookie& from);
  void MergeFrom(const Cookie& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ID = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:Cookie)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* id_;
  ::std::string* name_;
  friend void  protobuf_AddDesc_zoson_2eproto();
  friend void protobuf_AssignDesc_zoson_2eproto();
  friend void protobuf_ShutdownFile_zoson_2eproto();

  void InitAsDefaultInstance();
  static Cookie* default_instance_;
};
// -------------------------------------------------------------------

class Bytetranfer : public ::google::protobuf::Message {
 public:
  Bytetranfer();
  virtual ~Bytetranfer();

  Bytetranfer(const Bytetranfer& from);

  inline Bytetranfer& operator=(const Bytetranfer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Bytetranfer& default_instance();

  void Swap(Bytetranfer* other);

  // implements Message ----------------------------------------------

  Bytetranfer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Bytetranfer& from);
  void MergeFrom(const Bytetranfer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Bytetranfer)
 private:
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 count_;
  friend void  protobuf_AddDesc_zoson_2eproto();
  friend void protobuf_AssignDesc_zoson_2eproto();
  friend void protobuf_ShutdownFile_zoson_2eproto();

  void InitAsDefaultInstance();
  static Bytetranfer* default_instance_;
};
// -------------------------------------------------------------------

class VLayerInfos : public ::google::protobuf::Message {
 public:
  VLayerInfos();
  virtual ~VLayerInfos();

  VLayerInfos(const VLayerInfos& from);

  inline VLayerInfos& operator=(const VLayerInfos& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VLayerInfos& default_instance();

  void Swap(VLayerInfos* other);

  // implements Message ----------------------------------------------

  VLayerInfos* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VLayerInfos& from);
  void MergeFrom(const VLayerInfos& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .VLayerInfo infos = 1;
  inline int infos_size() const;
  inline void clear_infos();
  static const int kInfosFieldNumber = 1;
  inline const ::VLayerInfo& infos(int index) const;
  inline ::VLayerInfo* mutable_infos(int index);
  inline ::VLayerInfo* add_infos();
  inline const ::google::protobuf::RepeatedPtrField< ::VLayerInfo >&
      infos() const;
  inline ::google::protobuf::RepeatedPtrField< ::VLayerInfo >*
      mutable_infos();

  // @@protoc_insertion_point(class_scope:VLayerInfos)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::VLayerInfo > infos_;
  friend void  protobuf_AddDesc_zoson_2eproto();
  friend void protobuf_AssignDesc_zoson_2eproto();
  friend void protobuf_ShutdownFile_zoson_2eproto();

  void InitAsDefaultInstance();
  static VLayerInfos* default_instance_;
};
// -------------------------------------------------------------------

class VLayerInfo : public ::google::protobuf::Message {
 public:
  VLayerInfo();
  virtual ~VLayerInfo();

  VLayerInfo(const VLayerInfo& from);

  inline VLayerInfo& operator=(const VLayerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VLayerInfo& default_instance();

  void Swap(VLayerInfo* other);

  // implements Message ----------------------------------------------

  VLayerInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VLayerInfo& from);
  void MergeFrom(const VLayerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:VLayerInfo)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* type_;
  ::google::protobuf::int32 index_;
  friend void  protobuf_AddDesc_zoson_2eproto();
  friend void protobuf_AssignDesc_zoson_2eproto();
  friend void protobuf_ShutdownFile_zoson_2eproto();

  void InitAsDefaultInstance();
  static VLayerInfo* default_instance_;
};
// -------------------------------------------------------------------

class VFeatureMap : public ::google::protobuf::Message {
 public:
  VFeatureMap();
  virtual ~VFeatureMap();

  VFeatureMap(const VFeatureMap& from);

  inline VFeatureMap& operator=(const VFeatureMap& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VFeatureMap& default_instance();

  void Swap(VFeatureMap* other);

  // implements Message ----------------------------------------------

  VFeatureMap* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VFeatureMap& from);
  void MergeFrom(const VFeatureMap& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 width = 1;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 1;
  inline ::google::protobuf::int32 width() const;
  inline void set_width(::google::protobuf::int32 value);

  // required int32 height = 2;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 2;
  inline ::google::protobuf::int32 height() const;
  inline void set_height(::google::protobuf::int32 value);

  // required int32 num = 3;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 3;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // required int32 channel = 4;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 4;
  inline ::google::protobuf::int32 channel() const;
  inline void set_channel(::google::protobuf::int32 value);

  // required bytes data = 5;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 5;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:VFeatureMap)
 private:
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 height_;
  ::google::protobuf::int32 num_;
  ::google::protobuf::int32 channel_;
  ::std::string* data_;
  friend void  protobuf_AddDesc_zoson_2eproto();
  friend void protobuf_AssignDesc_zoson_2eproto();
  friend void protobuf_ShutdownFile_zoson_2eproto();

  void InitAsDefaultInstance();
  static VFeatureMap* default_instance_;
};
// -------------------------------------------------------------------

class VImage : public ::google::protobuf::Message {
 public:
  VImage();
  virtual ~VImage();

  VImage(const VImage& from);

  inline VImage& operator=(const VImage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VImage& default_instance();

  void Swap(VImage* other);

  // implements Message ----------------------------------------------

  VImage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VImage& from);
  void MergeFrom(const VImage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 width = 1;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 1;
  inline ::google::protobuf::int32 width() const;
  inline void set_width(::google::protobuf::int32 value);

  // required int32 height = 2;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 2;
  inline ::google::protobuf::int32 height() const;
  inline void set_height(::google::protobuf::int32 value);

  // required int32 channel = 3;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 3;
  inline ::google::protobuf::int32 channel() const;
  inline void set_channel(::google::protobuf::int32 value);

  // required bytes data = 4;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 4;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:VImage)
 private:
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 height_;
  ::std::string* data_;
  ::google::protobuf::int32 channel_;
  friend void  protobuf_AddDesc_zoson_2eproto();
  friend void protobuf_AssignDesc_zoson_2eproto();
  friend void protobuf_ShutdownFile_zoson_2eproto();

  void InitAsDefaultInstance();
  static VImage* default_instance_;
};
// -------------------------------------------------------------------

class VReqDeconv : public ::google::protobuf::Message {
 public:
  VReqDeconv();
  virtual ~VReqDeconv();

  VReqDeconv(const VReqDeconv& from);

  inline VReqDeconv& operator=(const VReqDeconv& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VReqDeconv& default_instance();

  void Swap(VReqDeconv* other);

  // implements Message ----------------------------------------------

  VReqDeconv* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VReqDeconv& from);
  void MergeFrom(const VReqDeconv& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 i_layer = 1;
  inline bool has_i_layer() const;
  inline void clear_i_layer();
  static const int kILayerFieldNumber = 1;
  inline ::google::protobuf::int32 i_layer() const;
  inline void set_i_layer(::google::protobuf::int32 value);

  // required int32 i_map = 2;
  inline bool has_i_map() const;
  inline void clear_i_map();
  static const int kIMapFieldNumber = 2;
  inline ::google::protobuf::int32 i_map() const;
  inline void set_i_map(::google::protobuf::int32 value);

  // optional bool do_deconv = 3 [default = false];
  inline bool has_do_deconv() const;
  inline void clear_do_deconv();
  static const int kDoDeconvFieldNumber = 3;
  inline bool do_deconv() const;
  inline void set_do_deconv(bool value);

  // @@protoc_insertion_point(class_scope:VReqDeconv)
 private:
  inline void set_has_i_layer();
  inline void clear_has_i_layer();
  inline void set_has_i_map();
  inline void clear_has_i_map();
  inline void set_has_do_deconv();
  inline void clear_has_do_deconv();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 i_layer_;
  ::google::protobuf::int32 i_map_;
  bool do_deconv_;
  friend void  protobuf_AddDesc_zoson_2eproto();
  friend void protobuf_AssignDesc_zoson_2eproto();
  friend void protobuf_ShutdownFile_zoson_2eproto();

  void InitAsDefaultInstance();
  static VReqDeconv* default_instance_;
};
// -------------------------------------------------------------------

class VSetting : public ::google::protobuf::Message {
 public:
  VSetting();
  virtual ~VSetting();

  VSetting(const VSetting& from);

  inline VSetting& operator=(const VSetting& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VSetting& default_instance();

  void Swap(VSetting* other);

  // implements Message ----------------------------------------------

  VSetting* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VSetting& from);
  void MergeFrom(const VSetting& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string model = 1;
  inline bool has_model() const;
  inline void clear_model();
  static const int kModelFieldNumber = 1;
  inline const ::std::string& model() const;
  inline void set_model(const ::std::string& value);
  inline void set_model(const char* value);
  inline void set_model(const char* value, size_t size);
  inline ::std::string* mutable_model();
  inline ::std::string* release_model();
  inline void set_allocated_model(::std::string* model);

  // required string solver = 2;
  inline bool has_solver() const;
  inline void clear_solver();
  static const int kSolverFieldNumber = 2;
  inline const ::std::string& solver() const;
  inline void set_solver(const ::std::string& value);
  inline void set_solver(const char* value);
  inline void set_solver(const char* value, size_t size);
  inline ::std::string* mutable_solver();
  inline ::std::string* release_solver();
  inline void set_allocated_solver(::std::string* solver);

  // required string test = 3;
  inline bool has_test() const;
  inline void clear_test();
  static const int kTestFieldNumber = 3;
  inline const ::std::string& test() const;
  inline void set_test(const ::std::string& value);
  inline void set_test(const char* value);
  inline void set_test(const char* value, size_t size);
  inline ::std::string* mutable_test();
  inline ::std::string* release_test();
  inline void set_allocated_test(::std::string* test);

  // optional int32 interval = 4 [default = -1];
  inline bool has_interval() const;
  inline void clear_interval();
  static const int kIntervalFieldNumber = 4;
  inline ::google::protobuf::int32 interval() const;
  inline void set_interval(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:VSetting)
 private:
  inline void set_has_model();
  inline void clear_has_model();
  inline void set_has_solver();
  inline void clear_has_solver();
  inline void set_has_test();
  inline void clear_has_test();
  inline void set_has_interval();
  inline void clear_has_interval();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* model_;
  ::std::string* solver_;
  ::std::string* test_;
  ::google::protobuf::int32 interval_;
  friend void  protobuf_AddDesc_zoson_2eproto();
  friend void protobuf_AssignDesc_zoson_2eproto();
  friend void protobuf_ShutdownFile_zoson_2eproto();

  void InitAsDefaultInstance();
  static VSetting* default_instance_;
};
// -------------------------------------------------------------------

class VResponse : public ::google::protobuf::Message {
 public:
  VResponse();
  virtual ~VResponse();

  VResponse(const VResponse& from);

  inline VResponse& operator=(const VResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VResponse& default_instance();

  void Swap(VResponse* other);

  // implements Message ----------------------------------------------

  VResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VResponse& from);
  void MergeFrom(const VResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef VResponse_Type Type;
  static const Type WEIGHT = VResponse_Type_WEIGHT;
  static const Type FEATUREMAP = VResponse_Type_FEATUREMAP;
  static const Type LAYERINFOS = VResponse_Type_LAYERINFOS;
  static const Type INPUT = VResponse_Type_INPUT;
  static const Type DECONV = VResponse_Type_DECONV;
  static const Type ALL = VResponse_Type_ALL;
  static const Type STATE = VResponse_Type_STATE;
  static const Type SETTING = VResponse_Type_SETTING;
  static inline bool Type_IsValid(int value) {
    return VResponse_Type_IsValid(value);
  }
  static const Type Type_MIN =
    VResponse_Type_Type_MIN;
  static const Type Type_MAX =
    VResponse_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    VResponse_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return VResponse_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return VResponse_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return VResponse_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .VResponse.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::VResponse_Type type() const;
  inline void set_type(::VResponse_Type value);

  // optional bytes data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:VResponse)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* data_;
  int type_;
  friend void  protobuf_AddDesc_zoson_2eproto();
  friend void protobuf_AssignDesc_zoson_2eproto();
  friend void protobuf_ShutdownFile_zoson_2eproto();

  void InitAsDefaultInstance();
  static VResponse* default_instance_;
};
// -------------------------------------------------------------------

class VAll : public ::google::protobuf::Message {
 public:
  VAll();
  virtual ~VAll();

  VAll(const VAll& from);

  inline VAll& operator=(const VAll& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VAll& default_instance();

  void Swap(VAll* other);

  // implements Message ----------------------------------------------

  VAll* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VAll& from);
  void MergeFrom(const VAll& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .VResponse response = 1;
  inline int response_size() const;
  inline void clear_response();
  static const int kResponseFieldNumber = 1;
  inline const ::VResponse& response(int index) const;
  inline ::VResponse* mutable_response(int index);
  inline ::VResponse* add_response();
  inline const ::google::protobuf::RepeatedPtrField< ::VResponse >&
      response() const;
  inline ::google::protobuf::RepeatedPtrField< ::VResponse >*
      mutable_response();

  // @@protoc_insertion_point(class_scope:VAll)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::VResponse > response_;
  friend void  protobuf_AddDesc_zoson_2eproto();
  friend void protobuf_AssignDesc_zoson_2eproto();
  friend void protobuf_ShutdownFile_zoson_2eproto();

  void InitAsDefaultInstance();
  static VAll* default_instance_;
};
// -------------------------------------------------------------------

class VReqFeature : public ::google::protobuf::Message {
 public:
  VReqFeature();
  virtual ~VReqFeature();

  VReqFeature(const VReqFeature& from);

  inline VReqFeature& operator=(const VReqFeature& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VReqFeature& default_instance();

  void Swap(VReqFeature* other);

  // implements Message ----------------------------------------------

  VReqFeature* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VReqFeature& from);
  void MergeFrom(const VReqFeature& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 i_layer = 1;
  inline bool has_i_layer() const;
  inline void clear_i_layer();
  static const int kILayerFieldNumber = 1;
  inline ::google::protobuf::int32 i_layer() const;
  inline void set_i_layer(::google::protobuf::int32 value);

  // required int32 i_image = 2;
  inline bool has_i_image() const;
  inline void clear_i_image();
  static const int kIImageFieldNumber = 2;
  inline ::google::protobuf::int32 i_image() const;
  inline void set_i_image(::google::protobuf::int32 value);

  // optional bool diff = 3 [default = false];
  inline bool has_diff() const;
  inline void clear_diff();
  static const int kDiffFieldNumber = 3;
  inline bool diff() const;
  inline void set_diff(bool value);

  // @@protoc_insertion_point(class_scope:VReqFeature)
 private:
  inline void set_has_i_layer();
  inline void clear_has_i_layer();
  inline void set_has_i_image();
  inline void clear_has_i_image();
  inline void set_has_diff();
  inline void clear_has_diff();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 i_layer_;
  ::google::protobuf::int32 i_image_;
  bool diff_;
  friend void  protobuf_AddDesc_zoson_2eproto();
  friend void protobuf_AssignDesc_zoson_2eproto();
  friend void protobuf_ShutdownFile_zoson_2eproto();

  void InitAsDefaultInstance();
  static VReqFeature* default_instance_;
};
// -------------------------------------------------------------------

class VReqWeight : public ::google::protobuf::Message {
 public:
  VReqWeight();
  virtual ~VReqWeight();

  VReqWeight(const VReqWeight& from);

  inline VReqWeight& operator=(const VReqWeight& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VReqWeight& default_instance();

  void Swap(VReqWeight* other);

  // implements Message ----------------------------------------------

  VReqWeight* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VReqWeight& from);
  void MergeFrom(const VReqWeight& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // optional bool diff = 2 [default = false];
  inline bool has_diff() const;
  inline void clear_diff();
  static const int kDiffFieldNumber = 2;
  inline bool diff() const;
  inline void set_diff(bool value);

  // @@protoc_insertion_point(class_scope:VReqWeight)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_diff();
  inline void clear_has_diff();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 index_;
  bool diff_;
  friend void  protobuf_AddDesc_zoson_2eproto();
  friend void protobuf_AssignDesc_zoson_2eproto();
  friend void protobuf_ShutdownFile_zoson_2eproto();

  void InitAsDefaultInstance();
  static VReqWeight* default_instance_;
};
// -------------------------------------------------------------------

class VState : public ::google::protobuf::Message {
 public:
  VState();
  virtual ~VState();

  VState(const VState& from);

  inline VState& operator=(const VState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VState& default_instance();

  void Swap(VState* other);

  // implements Message ----------------------------------------------

  VState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VState& from);
  void MergeFrom(const VState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool auto = 1 [default = true];
  inline bool has_auto_() const;
  inline void clear_auto_();
  static const int kAutoFieldNumber = 1;
  inline bool auto_() const;
  inline void set_auto_(bool value);

  // optional int32 input = 2 [default = -1];
  inline bool has_input() const;
  inline void clear_input();
  static const int kInputFieldNumber = 2;
  inline ::google::protobuf::int32 input() const;
  inline void set_input(::google::protobuf::int32 value);

  // optional .VReqFeature map = 3;
  inline bool has_map() const;
  inline void clear_map();
  static const int kMapFieldNumber = 3;
  inline const ::VReqFeature& map() const;
  inline ::VReqFeature* mutable_map();
  inline ::VReqFeature* release_map();
  inline void set_allocated_map(::VReqFeature* map);

  // optional .VReqDeconv deconv = 4;
  inline bool has_deconv() const;
  inline void clear_deconv();
  static const int kDeconvFieldNumber = 4;
  inline const ::VReqDeconv& deconv() const;
  inline ::VReqDeconv* mutable_deconv();
  inline ::VReqDeconv* release_deconv();
  inline void set_allocated_deconv(::VReqDeconv* deconv);

  // optional .VReqWeight weight = 5;
  inline bool has_weight() const;
  inline void clear_weight();
  static const int kWeightFieldNumber = 5;
  inline const ::VReqWeight& weight() const;
  inline ::VReqWeight* mutable_weight();
  inline ::VReqWeight* release_weight();
  inline void set_allocated_weight(::VReqWeight* weight);

  // @@protoc_insertion_point(class_scope:VState)
 private:
  inline void set_has_auto_();
  inline void clear_has_auto_();
  inline void set_has_input();
  inline void clear_has_input();
  inline void set_has_map();
  inline void clear_has_map();
  inline void set_has_deconv();
  inline void clear_has_deconv();
  inline void set_has_weight();
  inline void clear_has_weight();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool auto__;
  ::google::protobuf::int32 input_;
  ::VReqFeature* map_;
  ::VReqDeconv* deconv_;
  ::VReqWeight* weight_;
  friend void  protobuf_AddDesc_zoson_2eproto();
  friend void protobuf_AssignDesc_zoson_2eproto();
  friend void protobuf_ShutdownFile_zoson_2eproto();

  void InitAsDefaultInstance();
  static VState* default_instance_;
};
// ===================================================================


// ===================================================================

// TestProto

// required int32 clazz_num = 1;
inline bool TestProto::has_clazz_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TestProto::set_has_clazz_num() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TestProto::clear_has_clazz_num() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TestProto::clear_clazz_num() {
  clazz_num_ = 0;
  clear_has_clazz_num();
}
inline ::google::protobuf::int32 TestProto::clazz_num() const {
  // @@protoc_insertion_point(field_get:TestProto.clazz_num)
  return clazz_num_;
}
inline void TestProto::set_clazz_num(::google::protobuf::int32 value) {
  set_has_clazz_num();
  clazz_num_ = value;
  // @@protoc_insertion_point(field_set:TestProto.clazz_num)
}

// repeated int32 dim = 2;
inline int TestProto::dim_size() const {
  return dim_.size();
}
inline void TestProto::clear_dim() {
  dim_.Clear();
}
inline ::google::protobuf::int32 TestProto::dim(int index) const {
  // @@protoc_insertion_point(field_get:TestProto.dim)
  return dim_.Get(index);
}
inline void TestProto::set_dim(int index, ::google::protobuf::int32 value) {
  dim_.Set(index, value);
  // @@protoc_insertion_point(field_set:TestProto.dim)
}
inline void TestProto::add_dim(::google::protobuf::int32 value) {
  dim_.Add(value);
  // @@protoc_insertion_point(field_add:TestProto.dim)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
TestProto::dim() const {
  // @@protoc_insertion_point(field_list:TestProto.dim)
  return dim_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
TestProto::mutable_dim() {
  // @@protoc_insertion_point(field_mutable_list:TestProto.dim)
  return &dim_;
}

// -------------------------------------------------------------------

// DetectorParameter

// required string name = 1;
inline bool DetectorParameter::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DetectorParameter::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DetectorParameter::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DetectorParameter::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& DetectorParameter::name() const {
  // @@protoc_insertion_point(field_get:DetectorParameter.name)
  return *name_;
}
inline void DetectorParameter::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:DetectorParameter.name)
}
inline void DetectorParameter::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:DetectorParameter.name)
}
inline void DetectorParameter::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DetectorParameter.name)
}
inline ::std::string* DetectorParameter::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DetectorParameter.name)
  return name_;
}
inline ::std::string* DetectorParameter::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DetectorParameter::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DetectorParameter.name)
}

// required string model = 2;
inline bool DetectorParameter::has_model() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DetectorParameter::set_has_model() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DetectorParameter::clear_has_model() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DetectorParameter::clear_model() {
  if (model_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_->clear();
  }
  clear_has_model();
}
inline const ::std::string& DetectorParameter::model() const {
  // @@protoc_insertion_point(field_get:DetectorParameter.model)
  return *model_;
}
inline void DetectorParameter::set_model(const ::std::string& value) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_ = new ::std::string;
  }
  model_->assign(value);
  // @@protoc_insertion_point(field_set:DetectorParameter.model)
}
inline void DetectorParameter::set_model(const char* value) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_ = new ::std::string;
  }
  model_->assign(value);
  // @@protoc_insertion_point(field_set_char:DetectorParameter.model)
}
inline void DetectorParameter::set_model(const char* value, size_t size) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_ = new ::std::string;
  }
  model_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DetectorParameter.model)
}
inline ::std::string* DetectorParameter::mutable_model() {
  set_has_model();
  if (model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DetectorParameter.model)
  return model_;
}
inline ::std::string* DetectorParameter::release_model() {
  clear_has_model();
  if (model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = model_;
    model_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DetectorParameter::set_allocated_model(::std::string* model) {
  if (model_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete model_;
  }
  if (model) {
    set_has_model();
    model_ = model;
  } else {
    clear_has_model();
    model_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DetectorParameter.model)
}

// required string weight = 3;
inline bool DetectorParameter::has_weight() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DetectorParameter::set_has_weight() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DetectorParameter::clear_has_weight() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DetectorParameter::clear_weight() {
  if (weight_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    weight_->clear();
  }
  clear_has_weight();
}
inline const ::std::string& DetectorParameter::weight() const {
  // @@protoc_insertion_point(field_get:DetectorParameter.weight)
  return *weight_;
}
inline void DetectorParameter::set_weight(const ::std::string& value) {
  set_has_weight();
  if (weight_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    weight_ = new ::std::string;
  }
  weight_->assign(value);
  // @@protoc_insertion_point(field_set:DetectorParameter.weight)
}
inline void DetectorParameter::set_weight(const char* value) {
  set_has_weight();
  if (weight_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    weight_ = new ::std::string;
  }
  weight_->assign(value);
  // @@protoc_insertion_point(field_set_char:DetectorParameter.weight)
}
inline void DetectorParameter::set_weight(const char* value, size_t size) {
  set_has_weight();
  if (weight_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    weight_ = new ::std::string;
  }
  weight_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DetectorParameter.weight)
}
inline ::std::string* DetectorParameter::mutable_weight() {
  set_has_weight();
  if (weight_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    weight_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DetectorParameter.weight)
  return weight_;
}
inline ::std::string* DetectorParameter::release_weight() {
  clear_has_weight();
  if (weight_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = weight_;
    weight_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DetectorParameter::set_allocated_weight(::std::string* weight) {
  if (weight_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete weight_;
  }
  if (weight) {
    set_has_weight();
    weight_ = weight;
  } else {
    clear_has_weight();
    weight_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DetectorParameter.weight)
}

// optional bool use_gpu = 4 [default = true];
inline bool DetectorParameter::has_use_gpu() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DetectorParameter::set_has_use_gpu() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DetectorParameter::clear_has_use_gpu() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DetectorParameter::clear_use_gpu() {
  use_gpu_ = true;
  clear_has_use_gpu();
}
inline bool DetectorParameter::use_gpu() const {
  // @@protoc_insertion_point(field_get:DetectorParameter.use_gpu)
  return use_gpu_;
}
inline void DetectorParameter::set_use_gpu(bool value) {
  set_has_use_gpu();
  use_gpu_ = value;
  // @@protoc_insertion_point(field_set:DetectorParameter.use_gpu)
}

// optional bool do_vis = 5 [default = false];
inline bool DetectorParameter::has_do_vis() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DetectorParameter::set_has_do_vis() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DetectorParameter::clear_has_do_vis() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DetectorParameter::clear_do_vis() {
  do_vis_ = false;
  clear_has_do_vis();
}
inline bool DetectorParameter::do_vis() const {
  // @@protoc_insertion_point(field_get:DetectorParameter.do_vis)
  return do_vis_;
}
inline void DetectorParameter::set_do_vis(bool value) {
  set_has_do_vis();
  do_vis_ = value;
  // @@protoc_insertion_point(field_set:DetectorParameter.do_vis)
}

// optional int32 fq_vis = 6 [default = 10];
inline bool DetectorParameter::has_fq_vis() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DetectorParameter::set_has_fq_vis() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DetectorParameter::clear_has_fq_vis() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DetectorParameter::clear_fq_vis() {
  fq_vis_ = 10;
  clear_has_fq_vis();
}
inline ::google::protobuf::int32 DetectorParameter::fq_vis() const {
  // @@protoc_insertion_point(field_get:DetectorParameter.fq_vis)
  return fq_vis_;
}
inline void DetectorParameter::set_fq_vis(::google::protobuf::int32 value) {
  set_has_fq_vis();
  fq_vis_ = value;
  // @@protoc_insertion_point(field_set:DetectorParameter.fq_vis)
}

// optional float threshold = 7 [default = 0.5];
inline bool DetectorParameter::has_threshold() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DetectorParameter::set_has_threshold() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DetectorParameter::clear_has_threshold() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DetectorParameter::clear_threshold() {
  threshold_ = 0.5f;
  clear_has_threshold();
}
inline float DetectorParameter::threshold() const {
  // @@protoc_insertion_point(field_get:DetectorParameter.threshold)
  return threshold_;
}
inline void DetectorParameter::set_threshold(float value) {
  set_has_threshold();
  threshold_ = value;
  // @@protoc_insertion_point(field_set:DetectorParameter.threshold)
}

// optional bool shared = 8 [default = false];
inline bool DetectorParameter::has_shared() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DetectorParameter::set_has_shared() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DetectorParameter::clear_has_shared() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DetectorParameter::clear_shared() {
  shared_ = false;
  clear_has_shared();
}
inline bool DetectorParameter::shared() const {
  // @@protoc_insertion_point(field_get:DetectorParameter.shared)
  return shared_;
}
inline void DetectorParameter::set_shared(bool value) {
  set_has_shared();
  shared_ = value;
  // @@protoc_insertion_point(field_set:DetectorParameter.shared)
}

// optional bool istrain = 9 [default = false];
inline bool DetectorParameter::has_istrain() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DetectorParameter::set_has_istrain() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DetectorParameter::clear_has_istrain() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DetectorParameter::clear_istrain() {
  istrain_ = false;
  clear_has_istrain();
}
inline bool DetectorParameter::istrain() const {
  // @@protoc_insertion_point(field_get:DetectorParameter.istrain)
  return istrain_;
}
inline void DetectorParameter::set_istrain(bool value) {
  set_has_istrain();
  istrain_ = value;
  // @@protoc_insertion_point(field_set:DetectorParameter.istrain)
}

// optional string solver = 10;
inline bool DetectorParameter::has_solver() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DetectorParameter::set_has_solver() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DetectorParameter::clear_has_solver() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DetectorParameter::clear_solver() {
  if (solver_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    solver_->clear();
  }
  clear_has_solver();
}
inline const ::std::string& DetectorParameter::solver() const {
  // @@protoc_insertion_point(field_get:DetectorParameter.solver)
  return *solver_;
}
inline void DetectorParameter::set_solver(const ::std::string& value) {
  set_has_solver();
  if (solver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    solver_ = new ::std::string;
  }
  solver_->assign(value);
  // @@protoc_insertion_point(field_set:DetectorParameter.solver)
}
inline void DetectorParameter::set_solver(const char* value) {
  set_has_solver();
  if (solver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    solver_ = new ::std::string;
  }
  solver_->assign(value);
  // @@protoc_insertion_point(field_set_char:DetectorParameter.solver)
}
inline void DetectorParameter::set_solver(const char* value, size_t size) {
  set_has_solver();
  if (solver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    solver_ = new ::std::string;
  }
  solver_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DetectorParameter.solver)
}
inline ::std::string* DetectorParameter::mutable_solver() {
  set_has_solver();
  if (solver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    solver_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DetectorParameter.solver)
  return solver_;
}
inline ::std::string* DetectorParameter::release_solver() {
  clear_has_solver();
  if (solver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = solver_;
    solver_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DetectorParameter::set_allocated_solver(::std::string* solver) {
  if (solver_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete solver_;
  }
  if (solver) {
    set_has_solver();
    solver_ = solver;
  } else {
    clear_has_solver();
    solver_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DetectorParameter.solver)
}

// optional string snapshot = 11;
inline bool DetectorParameter::has_snapshot() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DetectorParameter::set_has_snapshot() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DetectorParameter::clear_has_snapshot() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DetectorParameter::clear_snapshot() {
  if (snapshot_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    snapshot_->clear();
  }
  clear_has_snapshot();
}
inline const ::std::string& DetectorParameter::snapshot() const {
  // @@protoc_insertion_point(field_get:DetectorParameter.snapshot)
  return *snapshot_;
}
inline void DetectorParameter::set_snapshot(const ::std::string& value) {
  set_has_snapshot();
  if (snapshot_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    snapshot_ = new ::std::string;
  }
  snapshot_->assign(value);
  // @@protoc_insertion_point(field_set:DetectorParameter.snapshot)
}
inline void DetectorParameter::set_snapshot(const char* value) {
  set_has_snapshot();
  if (snapshot_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    snapshot_ = new ::std::string;
  }
  snapshot_->assign(value);
  // @@protoc_insertion_point(field_set_char:DetectorParameter.snapshot)
}
inline void DetectorParameter::set_snapshot(const char* value, size_t size) {
  set_has_snapshot();
  if (snapshot_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    snapshot_ = new ::std::string;
  }
  snapshot_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DetectorParameter.snapshot)
}
inline ::std::string* DetectorParameter::mutable_snapshot() {
  set_has_snapshot();
  if (snapshot_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    snapshot_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DetectorParameter.snapshot)
  return snapshot_;
}
inline ::std::string* DetectorParameter::release_snapshot() {
  clear_has_snapshot();
  if (snapshot_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = snapshot_;
    snapshot_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DetectorParameter::set_allocated_snapshot(::std::string* snapshot) {
  if (snapshot_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete snapshot_;
  }
  if (snapshot) {
    set_has_snapshot();
    snapshot_ = snapshot;
  } else {
    clear_has_snapshot();
    snapshot_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DetectorParameter.snapshot)
}

// -------------------------------------------------------------------

// DetectInput

// required int32 width = 2;
inline bool DetectInput::has_width() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DetectInput::set_has_width() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DetectInput::clear_has_width() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DetectInput::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline ::google::protobuf::int32 DetectInput::width() const {
  // @@protoc_insertion_point(field_get:DetectInput.width)
  return width_;
}
inline void DetectInput::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:DetectInput.width)
}

// required int32 height = 3;
inline bool DetectInput::has_height() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DetectInput::set_has_height() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DetectInput::clear_has_height() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DetectInput::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline ::google::protobuf::int32 DetectInput::height() const {
  // @@protoc_insertion_point(field_get:DetectInput.height)
  return height_;
}
inline void DetectInput::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:DetectInput.height)
}

// required bytes data = 4;
inline bool DetectInput::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DetectInput::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DetectInput::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DetectInput::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& DetectInput::data() const {
  // @@protoc_insertion_point(field_get:DetectInput.data)
  return *data_;
}
inline void DetectInput::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:DetectInput.data)
}
inline void DetectInput::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:DetectInput.data)
}
inline void DetectInput::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DetectInput.data)
}
inline ::std::string* DetectInput::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DetectInput.data)
  return data_;
}
inline ::std::string* DetectInput::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DetectInput::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DetectInput.data)
}

// -------------------------------------------------------------------

// DetectOutput

// repeated .Result results = 1;
inline int DetectOutput::results_size() const {
  return results_.size();
}
inline void DetectOutput::clear_results() {
  results_.Clear();
}
inline const ::Result& DetectOutput::results(int index) const {
  // @@protoc_insertion_point(field_get:DetectOutput.results)
  return results_.Get(index);
}
inline ::Result* DetectOutput::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:DetectOutput.results)
  return results_.Mutable(index);
}
inline ::Result* DetectOutput::add_results() {
  // @@protoc_insertion_point(field_add:DetectOutput.results)
  return results_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Result >&
DetectOutput::results() const {
  // @@protoc_insertion_point(field_list:DetectOutput.results)
  return results_;
}
inline ::google::protobuf::RepeatedPtrField< ::Result >*
DetectOutput::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:DetectOutput.results)
  return &results_;
}

// -------------------------------------------------------------------

// Result

// required float xmin = 1;
inline bool Result::has_xmin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Result::set_has_xmin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Result::clear_has_xmin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Result::clear_xmin() {
  xmin_ = 0;
  clear_has_xmin();
}
inline float Result::xmin() const {
  // @@protoc_insertion_point(field_get:Result.xmin)
  return xmin_;
}
inline void Result::set_xmin(float value) {
  set_has_xmin();
  xmin_ = value;
  // @@protoc_insertion_point(field_set:Result.xmin)
}

// required float ymin = 2;
inline bool Result::has_ymin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Result::set_has_ymin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Result::clear_has_ymin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Result::clear_ymin() {
  ymin_ = 0;
  clear_has_ymin();
}
inline float Result::ymin() const {
  // @@protoc_insertion_point(field_get:Result.ymin)
  return ymin_;
}
inline void Result::set_ymin(float value) {
  set_has_ymin();
  ymin_ = value;
  // @@protoc_insertion_point(field_set:Result.ymin)
}

// required float xmax = 3;
inline bool Result::has_xmax() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Result::set_has_xmax() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Result::clear_has_xmax() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Result::clear_xmax() {
  xmax_ = 0;
  clear_has_xmax();
}
inline float Result::xmax() const {
  // @@protoc_insertion_point(field_get:Result.xmax)
  return xmax_;
}
inline void Result::set_xmax(float value) {
  set_has_xmax();
  xmax_ = value;
  // @@protoc_insertion_point(field_set:Result.xmax)
}

// required float ymax = 4;
inline bool Result::has_ymax() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Result::set_has_ymax() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Result::clear_has_ymax() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Result::clear_ymax() {
  ymax_ = 0;
  clear_has_ymax();
}
inline float Result::ymax() const {
  // @@protoc_insertion_point(field_get:Result.ymax)
  return ymax_;
}
inline void Result::set_ymax(float value) {
  set_has_ymax();
  ymax_ = value;
  // @@protoc_insertion_point(field_set:Result.ymax)
}

// required int32 clazz = 5;
inline bool Result::has_clazz() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Result::set_has_clazz() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Result::clear_has_clazz() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Result::clear_clazz() {
  clazz_ = 0;
  clear_has_clazz();
}
inline ::google::protobuf::int32 Result::clazz() const {
  // @@protoc_insertion_point(field_get:Result.clazz)
  return clazz_;
}
inline void Result::set_clazz(::google::protobuf::int32 value) {
  set_has_clazz();
  clazz_ = value;
  // @@protoc_insertion_point(field_set:Result.clazz)
}

// required float score = 6;
inline bool Result::has_score() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Result::set_has_score() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Result::clear_has_score() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Result::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline float Result::score() const {
  // @@protoc_insertion_point(field_get:Result.score)
  return score_;
}
inline void Result::set_score(float value) {
  set_has_score();
  score_ = value;
  // @@protoc_insertion_point(field_set:Result.score)
}

// -------------------------------------------------------------------

// CommuParameter

// optional string address = 1 [default = "localhost"];
inline bool CommuParameter::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommuParameter::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommuParameter::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommuParameter::clear_address() {
  if (address_ != _default_address_) {
    address_->assign(*_default_address_);
  }
  clear_has_address();
}
inline const ::std::string& CommuParameter::address() const {
  // @@protoc_insertion_point(field_get:CommuParameter.address)
  return *address_;
}
inline void CommuParameter::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == _default_address_) {
    address_ = new ::std::string;
  }
  address_->assign(value);
  // @@protoc_insertion_point(field_set:CommuParameter.address)
}
inline void CommuParameter::set_address(const char* value) {
  set_has_address();
  if (address_ == _default_address_) {
    address_ = new ::std::string;
  }
  address_->assign(value);
  // @@protoc_insertion_point(field_set_char:CommuParameter.address)
}
inline void CommuParameter::set_address(const char* value, size_t size) {
  set_has_address();
  if (address_ == _default_address_) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CommuParameter.address)
}
inline ::std::string* CommuParameter::mutable_address() {
  set_has_address();
  if (address_ == _default_address_) {
    address_ = new ::std::string(*_default_address_);
  }
  // @@protoc_insertion_point(field_mutable:CommuParameter.address)
  return address_;
}
inline ::std::string* CommuParameter::release_address() {
  clear_has_address();
  if (address_ == _default_address_) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(_default_address_);
    return temp;
  }
}
inline void CommuParameter::set_allocated_address(::std::string* address) {
  if (address_ != _default_address_) {
    delete address_;
  }
  if (address) {
    set_has_address();
    address_ = address;
  } else {
    clear_has_address();
    address_ = const_cast< ::std::string*>(_default_address_);
  }
  // @@protoc_insertion_point(field_set_allocated:CommuParameter.address)
}

// optional int32 port = 2 [default = 10086];
inline bool CommuParameter::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommuParameter::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommuParameter::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommuParameter::clear_port() {
  port_ = 10086;
  clear_has_port();
}
inline ::google::protobuf::int32 CommuParameter::port() const {
  // @@protoc_insertion_point(field_get:CommuParameter.port)
  return port_;
}
inline void CommuParameter::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:CommuParameter.port)
}

// optional string client_name = 3 [default = "web"];
inline bool CommuParameter::has_client_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommuParameter::set_has_client_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommuParameter::clear_has_client_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommuParameter::clear_client_name() {
  if (client_name_ != _default_client_name_) {
    client_name_->assign(*_default_client_name_);
  }
  clear_has_client_name();
}
inline const ::std::string& CommuParameter::client_name() const {
  // @@protoc_insertion_point(field_get:CommuParameter.client_name)
  return *client_name_;
}
inline void CommuParameter::set_client_name(const ::std::string& value) {
  set_has_client_name();
  if (client_name_ == _default_client_name_) {
    client_name_ = new ::std::string;
  }
  client_name_->assign(value);
  // @@protoc_insertion_point(field_set:CommuParameter.client_name)
}
inline void CommuParameter::set_client_name(const char* value) {
  set_has_client_name();
  if (client_name_ == _default_client_name_) {
    client_name_ = new ::std::string;
  }
  client_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:CommuParameter.client_name)
}
inline void CommuParameter::set_client_name(const char* value, size_t size) {
  set_has_client_name();
  if (client_name_ == _default_client_name_) {
    client_name_ = new ::std::string;
  }
  client_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CommuParameter.client_name)
}
inline ::std::string* CommuParameter::mutable_client_name() {
  set_has_client_name();
  if (client_name_ == _default_client_name_) {
    client_name_ = new ::std::string(*_default_client_name_);
  }
  // @@protoc_insertion_point(field_mutable:CommuParameter.client_name)
  return client_name_;
}
inline ::std::string* CommuParameter::release_client_name() {
  clear_has_client_name();
  if (client_name_ == _default_client_name_) {
    return NULL;
  } else {
    ::std::string* temp = client_name_;
    client_name_ = const_cast< ::std::string*>(_default_client_name_);
    return temp;
  }
}
inline void CommuParameter::set_allocated_client_name(::std::string* client_name) {
  if (client_name_ != _default_client_name_) {
    delete client_name_;
  }
  if (client_name) {
    set_has_client_name();
    client_name_ = client_name;
  } else {
    clear_has_client_name();
    client_name_ = const_cast< ::std::string*>(_default_client_name_);
  }
  // @@protoc_insertion_point(field_set_allocated:CommuParameter.client_name)
}

// optional .CommuParameter.Type type = 4 [default = LOC];
inline bool CommuParameter::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommuParameter::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommuParameter::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommuParameter::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::CommuParameter_Type CommuParameter::type() const {
  // @@protoc_insertion_point(field_get:CommuParameter.type)
  return static_cast< ::CommuParameter_Type >(type_);
}
inline void CommuParameter::set_type(::CommuParameter_Type value) {
  assert(::CommuParameter_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:CommuParameter.type)
}

// -------------------------------------------------------------------

// ClassMaps

// repeated .ClassMap item = 1;
inline int ClassMaps::item_size() const {
  return item_.size();
}
inline void ClassMaps::clear_item() {
  item_.Clear();
}
inline const ::ClassMap& ClassMaps::item(int index) const {
  // @@protoc_insertion_point(field_get:ClassMaps.item)
  return item_.Get(index);
}
inline ::ClassMap* ClassMaps::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:ClassMaps.item)
  return item_.Mutable(index);
}
inline ::ClassMap* ClassMaps::add_item() {
  // @@protoc_insertion_point(field_add:ClassMaps.item)
  return item_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ClassMap >&
ClassMaps::item() const {
  // @@protoc_insertion_point(field_list:ClassMaps.item)
  return item_;
}
inline ::google::protobuf::RepeatedPtrField< ::ClassMap >*
ClassMaps::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:ClassMaps.item)
  return &item_;
}

// -------------------------------------------------------------------

// ClassMap

// required string name = 1;
inline bool ClassMap::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClassMap::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClassMap::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClassMap::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ClassMap::name() const {
  // @@protoc_insertion_point(field_get:ClassMap.name)
  return *name_;
}
inline void ClassMap::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:ClassMap.name)
}
inline void ClassMap::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:ClassMap.name)
}
inline void ClassMap::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ClassMap.name)
}
inline ::std::string* ClassMap::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ClassMap.name)
  return name_;
}
inline ::std::string* ClassMap::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ClassMap::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ClassMap.name)
}

// required int32 label = 2;
inline bool ClassMap::has_label() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClassMap::set_has_label() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClassMap::clear_has_label() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClassMap::clear_label() {
  label_ = 0;
  clear_has_label();
}
inline ::google::protobuf::int32 ClassMap::label() const {
  // @@protoc_insertion_point(field_get:ClassMap.label)
  return label_;
}
inline void ClassMap::set_label(::google::protobuf::int32 value) {
  set_has_label();
  label_ = value;
  // @@protoc_insertion_point(field_set:ClassMap.label)
}

// required string display_name = 3;
inline bool ClassMap::has_display_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClassMap::set_has_display_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClassMap::clear_has_display_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClassMap::clear_display_name() {
  if (display_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    display_name_->clear();
  }
  clear_has_display_name();
}
inline const ::std::string& ClassMap::display_name() const {
  // @@protoc_insertion_point(field_get:ClassMap.display_name)
  return *display_name_;
}
inline void ClassMap::set_display_name(const ::std::string& value) {
  set_has_display_name();
  if (display_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    display_name_ = new ::std::string;
  }
  display_name_->assign(value);
  // @@protoc_insertion_point(field_set:ClassMap.display_name)
}
inline void ClassMap::set_display_name(const char* value) {
  set_has_display_name();
  if (display_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    display_name_ = new ::std::string;
  }
  display_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:ClassMap.display_name)
}
inline void ClassMap::set_display_name(const char* value, size_t size) {
  set_has_display_name();
  if (display_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    display_name_ = new ::std::string;
  }
  display_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ClassMap.display_name)
}
inline ::std::string* ClassMap::mutable_display_name() {
  set_has_display_name();
  if (display_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    display_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ClassMap.display_name)
  return display_name_;
}
inline ::std::string* ClassMap::release_display_name() {
  clear_has_display_name();
  if (display_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = display_name_;
    display_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ClassMap::set_allocated_display_name(::std::string* display_name) {
  if (display_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete display_name_;
  }
  if (display_name) {
    set_has_display_name();
    display_name_ = display_name;
  } else {
    clear_has_display_name();
    display_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ClassMap.display_name)
}

// -------------------------------------------------------------------

// Cookie

// required string ID = 1;
inline bool Cookie::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Cookie::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Cookie::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Cookie::clear_id() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& Cookie::id() const {
  // @@protoc_insertion_point(field_get:Cookie.ID)
  return *id_;
}
inline void Cookie::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set:Cookie.ID)
}
inline void Cookie::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set_char:Cookie.ID)
}
inline void Cookie::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Cookie.ID)
}
inline ::std::string* Cookie::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Cookie.ID)
  return id_;
}
inline ::std::string* Cookie::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Cookie::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Cookie.ID)
}

// required string name = 2;
inline bool Cookie::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Cookie::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Cookie::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Cookie::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Cookie::name() const {
  // @@protoc_insertion_point(field_get:Cookie.name)
  return *name_;
}
inline void Cookie::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:Cookie.name)
}
inline void Cookie::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Cookie.name)
}
inline void Cookie::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Cookie.name)
}
inline ::std::string* Cookie::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Cookie.name)
  return name_;
}
inline ::std::string* Cookie::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Cookie::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Cookie.name)
}

// -------------------------------------------------------------------

// Bytetranfer

// required int32 count = 2;
inline bool Bytetranfer::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Bytetranfer::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Bytetranfer::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Bytetranfer::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 Bytetranfer::count() const {
  // @@protoc_insertion_point(field_get:Bytetranfer.count)
  return count_;
}
inline void Bytetranfer::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:Bytetranfer.count)
}

// -------------------------------------------------------------------

// VLayerInfos

// repeated .VLayerInfo infos = 1;
inline int VLayerInfos::infos_size() const {
  return infos_.size();
}
inline void VLayerInfos::clear_infos() {
  infos_.Clear();
}
inline const ::VLayerInfo& VLayerInfos::infos(int index) const {
  // @@protoc_insertion_point(field_get:VLayerInfos.infos)
  return infos_.Get(index);
}
inline ::VLayerInfo* VLayerInfos::mutable_infos(int index) {
  // @@protoc_insertion_point(field_mutable:VLayerInfos.infos)
  return infos_.Mutable(index);
}
inline ::VLayerInfo* VLayerInfos::add_infos() {
  // @@protoc_insertion_point(field_add:VLayerInfos.infos)
  return infos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::VLayerInfo >&
VLayerInfos::infos() const {
  // @@protoc_insertion_point(field_list:VLayerInfos.infos)
  return infos_;
}
inline ::google::protobuf::RepeatedPtrField< ::VLayerInfo >*
VLayerInfos::mutable_infos() {
  // @@protoc_insertion_point(field_mutable_list:VLayerInfos.infos)
  return &infos_;
}

// -------------------------------------------------------------------

// VLayerInfo

// required int32 index = 1;
inline bool VLayerInfo::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VLayerInfo::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VLayerInfo::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VLayerInfo::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 VLayerInfo::index() const {
  // @@protoc_insertion_point(field_get:VLayerInfo.index)
  return index_;
}
inline void VLayerInfo::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:VLayerInfo.index)
}

// required string name = 2;
inline bool VLayerInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VLayerInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VLayerInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VLayerInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& VLayerInfo::name() const {
  // @@protoc_insertion_point(field_get:VLayerInfo.name)
  return *name_;
}
inline void VLayerInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:VLayerInfo.name)
}
inline void VLayerInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:VLayerInfo.name)
}
inline void VLayerInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:VLayerInfo.name)
}
inline ::std::string* VLayerInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:VLayerInfo.name)
  return name_;
}
inline ::std::string* VLayerInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VLayerInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:VLayerInfo.name)
}

// required string type = 3;
inline bool VLayerInfo::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VLayerInfo::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VLayerInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VLayerInfo::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& VLayerInfo::type() const {
  // @@protoc_insertion_point(field_get:VLayerInfo.type)
  return *type_;
}
inline void VLayerInfo::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:VLayerInfo.type)
}
inline void VLayerInfo::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:VLayerInfo.type)
}
inline void VLayerInfo::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:VLayerInfo.type)
}
inline ::std::string* VLayerInfo::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:VLayerInfo.type)
  return type_;
}
inline ::std::string* VLayerInfo::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VLayerInfo::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:VLayerInfo.type)
}

// -------------------------------------------------------------------

// VFeatureMap

// required int32 width = 1;
inline bool VFeatureMap::has_width() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VFeatureMap::set_has_width() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VFeatureMap::clear_has_width() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VFeatureMap::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline ::google::protobuf::int32 VFeatureMap::width() const {
  // @@protoc_insertion_point(field_get:VFeatureMap.width)
  return width_;
}
inline void VFeatureMap::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:VFeatureMap.width)
}

// required int32 height = 2;
inline bool VFeatureMap::has_height() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VFeatureMap::set_has_height() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VFeatureMap::clear_has_height() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VFeatureMap::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline ::google::protobuf::int32 VFeatureMap::height() const {
  // @@protoc_insertion_point(field_get:VFeatureMap.height)
  return height_;
}
inline void VFeatureMap::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:VFeatureMap.height)
}

// required int32 num = 3;
inline bool VFeatureMap::has_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VFeatureMap::set_has_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VFeatureMap::clear_has_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VFeatureMap::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 VFeatureMap::num() const {
  // @@protoc_insertion_point(field_get:VFeatureMap.num)
  return num_;
}
inline void VFeatureMap::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
  // @@protoc_insertion_point(field_set:VFeatureMap.num)
}

// required int32 channel = 4;
inline bool VFeatureMap::has_channel() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VFeatureMap::set_has_channel() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VFeatureMap::clear_has_channel() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VFeatureMap::clear_channel() {
  channel_ = 0;
  clear_has_channel();
}
inline ::google::protobuf::int32 VFeatureMap::channel() const {
  // @@protoc_insertion_point(field_get:VFeatureMap.channel)
  return channel_;
}
inline void VFeatureMap::set_channel(::google::protobuf::int32 value) {
  set_has_channel();
  channel_ = value;
  // @@protoc_insertion_point(field_set:VFeatureMap.channel)
}

// required bytes data = 5;
inline bool VFeatureMap::has_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VFeatureMap::set_has_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VFeatureMap::clear_has_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VFeatureMap::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& VFeatureMap::data() const {
  // @@protoc_insertion_point(field_get:VFeatureMap.data)
  return *data_;
}
inline void VFeatureMap::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:VFeatureMap.data)
}
inline void VFeatureMap::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:VFeatureMap.data)
}
inline void VFeatureMap::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:VFeatureMap.data)
}
inline ::std::string* VFeatureMap::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:VFeatureMap.data)
  return data_;
}
inline ::std::string* VFeatureMap::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VFeatureMap::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:VFeatureMap.data)
}

// -------------------------------------------------------------------

// VImage

// required int32 width = 1;
inline bool VImage::has_width() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VImage::set_has_width() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VImage::clear_has_width() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VImage::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline ::google::protobuf::int32 VImage::width() const {
  // @@protoc_insertion_point(field_get:VImage.width)
  return width_;
}
inline void VImage::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:VImage.width)
}

// required int32 height = 2;
inline bool VImage::has_height() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VImage::set_has_height() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VImage::clear_has_height() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VImage::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline ::google::protobuf::int32 VImage::height() const {
  // @@protoc_insertion_point(field_get:VImage.height)
  return height_;
}
inline void VImage::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:VImage.height)
}

// required int32 channel = 3;
inline bool VImage::has_channel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VImage::set_has_channel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VImage::clear_has_channel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VImage::clear_channel() {
  channel_ = 0;
  clear_has_channel();
}
inline ::google::protobuf::int32 VImage::channel() const {
  // @@protoc_insertion_point(field_get:VImage.channel)
  return channel_;
}
inline void VImage::set_channel(::google::protobuf::int32 value) {
  set_has_channel();
  channel_ = value;
  // @@protoc_insertion_point(field_set:VImage.channel)
}

// required bytes data = 4;
inline bool VImage::has_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VImage::set_has_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VImage::clear_has_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VImage::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& VImage::data() const {
  // @@protoc_insertion_point(field_get:VImage.data)
  return *data_;
}
inline void VImage::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:VImage.data)
}
inline void VImage::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:VImage.data)
}
inline void VImage::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:VImage.data)
}
inline ::std::string* VImage::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:VImage.data)
  return data_;
}
inline ::std::string* VImage::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VImage::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:VImage.data)
}

// -------------------------------------------------------------------

// VReqDeconv

// required int32 i_layer = 1;
inline bool VReqDeconv::has_i_layer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VReqDeconv::set_has_i_layer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VReqDeconv::clear_has_i_layer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VReqDeconv::clear_i_layer() {
  i_layer_ = 0;
  clear_has_i_layer();
}
inline ::google::protobuf::int32 VReqDeconv::i_layer() const {
  // @@protoc_insertion_point(field_get:VReqDeconv.i_layer)
  return i_layer_;
}
inline void VReqDeconv::set_i_layer(::google::protobuf::int32 value) {
  set_has_i_layer();
  i_layer_ = value;
  // @@protoc_insertion_point(field_set:VReqDeconv.i_layer)
}

// required int32 i_map = 2;
inline bool VReqDeconv::has_i_map() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VReqDeconv::set_has_i_map() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VReqDeconv::clear_has_i_map() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VReqDeconv::clear_i_map() {
  i_map_ = 0;
  clear_has_i_map();
}
inline ::google::protobuf::int32 VReqDeconv::i_map() const {
  // @@protoc_insertion_point(field_get:VReqDeconv.i_map)
  return i_map_;
}
inline void VReqDeconv::set_i_map(::google::protobuf::int32 value) {
  set_has_i_map();
  i_map_ = value;
  // @@protoc_insertion_point(field_set:VReqDeconv.i_map)
}

// optional bool do_deconv = 3 [default = false];
inline bool VReqDeconv::has_do_deconv() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VReqDeconv::set_has_do_deconv() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VReqDeconv::clear_has_do_deconv() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VReqDeconv::clear_do_deconv() {
  do_deconv_ = false;
  clear_has_do_deconv();
}
inline bool VReqDeconv::do_deconv() const {
  // @@protoc_insertion_point(field_get:VReqDeconv.do_deconv)
  return do_deconv_;
}
inline void VReqDeconv::set_do_deconv(bool value) {
  set_has_do_deconv();
  do_deconv_ = value;
  // @@protoc_insertion_point(field_set:VReqDeconv.do_deconv)
}

// -------------------------------------------------------------------

// VSetting

// required string model = 1;
inline bool VSetting::has_model() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VSetting::set_has_model() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VSetting::clear_has_model() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VSetting::clear_model() {
  if (model_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_->clear();
  }
  clear_has_model();
}
inline const ::std::string& VSetting::model() const {
  // @@protoc_insertion_point(field_get:VSetting.model)
  return *model_;
}
inline void VSetting::set_model(const ::std::string& value) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_ = new ::std::string;
  }
  model_->assign(value);
  // @@protoc_insertion_point(field_set:VSetting.model)
}
inline void VSetting::set_model(const char* value) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_ = new ::std::string;
  }
  model_->assign(value);
  // @@protoc_insertion_point(field_set_char:VSetting.model)
}
inline void VSetting::set_model(const char* value, size_t size) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_ = new ::std::string;
  }
  model_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:VSetting.model)
}
inline ::std::string* VSetting::mutable_model() {
  set_has_model();
  if (model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:VSetting.model)
  return model_;
}
inline ::std::string* VSetting::release_model() {
  clear_has_model();
  if (model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = model_;
    model_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VSetting::set_allocated_model(::std::string* model) {
  if (model_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete model_;
  }
  if (model) {
    set_has_model();
    model_ = model;
  } else {
    clear_has_model();
    model_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:VSetting.model)
}

// required string solver = 2;
inline bool VSetting::has_solver() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VSetting::set_has_solver() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VSetting::clear_has_solver() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VSetting::clear_solver() {
  if (solver_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    solver_->clear();
  }
  clear_has_solver();
}
inline const ::std::string& VSetting::solver() const {
  // @@protoc_insertion_point(field_get:VSetting.solver)
  return *solver_;
}
inline void VSetting::set_solver(const ::std::string& value) {
  set_has_solver();
  if (solver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    solver_ = new ::std::string;
  }
  solver_->assign(value);
  // @@protoc_insertion_point(field_set:VSetting.solver)
}
inline void VSetting::set_solver(const char* value) {
  set_has_solver();
  if (solver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    solver_ = new ::std::string;
  }
  solver_->assign(value);
  // @@protoc_insertion_point(field_set_char:VSetting.solver)
}
inline void VSetting::set_solver(const char* value, size_t size) {
  set_has_solver();
  if (solver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    solver_ = new ::std::string;
  }
  solver_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:VSetting.solver)
}
inline ::std::string* VSetting::mutable_solver() {
  set_has_solver();
  if (solver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    solver_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:VSetting.solver)
  return solver_;
}
inline ::std::string* VSetting::release_solver() {
  clear_has_solver();
  if (solver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = solver_;
    solver_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VSetting::set_allocated_solver(::std::string* solver) {
  if (solver_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete solver_;
  }
  if (solver) {
    set_has_solver();
    solver_ = solver;
  } else {
    clear_has_solver();
    solver_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:VSetting.solver)
}

// required string test = 3;
inline bool VSetting::has_test() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VSetting::set_has_test() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VSetting::clear_has_test() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VSetting::clear_test() {
  if (test_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    test_->clear();
  }
  clear_has_test();
}
inline const ::std::string& VSetting::test() const {
  // @@protoc_insertion_point(field_get:VSetting.test)
  return *test_;
}
inline void VSetting::set_test(const ::std::string& value) {
  set_has_test();
  if (test_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    test_ = new ::std::string;
  }
  test_->assign(value);
  // @@protoc_insertion_point(field_set:VSetting.test)
}
inline void VSetting::set_test(const char* value) {
  set_has_test();
  if (test_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    test_ = new ::std::string;
  }
  test_->assign(value);
  // @@protoc_insertion_point(field_set_char:VSetting.test)
}
inline void VSetting::set_test(const char* value, size_t size) {
  set_has_test();
  if (test_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    test_ = new ::std::string;
  }
  test_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:VSetting.test)
}
inline ::std::string* VSetting::mutable_test() {
  set_has_test();
  if (test_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    test_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:VSetting.test)
  return test_;
}
inline ::std::string* VSetting::release_test() {
  clear_has_test();
  if (test_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = test_;
    test_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VSetting::set_allocated_test(::std::string* test) {
  if (test_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete test_;
  }
  if (test) {
    set_has_test();
    test_ = test;
  } else {
    clear_has_test();
    test_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:VSetting.test)
}

// optional int32 interval = 4 [default = -1];
inline bool VSetting::has_interval() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VSetting::set_has_interval() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VSetting::clear_has_interval() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VSetting::clear_interval() {
  interval_ = -1;
  clear_has_interval();
}
inline ::google::protobuf::int32 VSetting::interval() const {
  // @@protoc_insertion_point(field_get:VSetting.interval)
  return interval_;
}
inline void VSetting::set_interval(::google::protobuf::int32 value) {
  set_has_interval();
  interval_ = value;
  // @@protoc_insertion_point(field_set:VSetting.interval)
}

// -------------------------------------------------------------------

// VResponse

// required .VResponse.Type type = 1;
inline bool VResponse::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VResponse::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VResponse::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VResponse::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::VResponse_Type VResponse::type() const {
  // @@protoc_insertion_point(field_get:VResponse.type)
  return static_cast< ::VResponse_Type >(type_);
}
inline void VResponse::set_type(::VResponse_Type value) {
  assert(::VResponse_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:VResponse.type)
}

// optional bytes data = 2;
inline bool VResponse::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VResponse::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VResponse::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VResponse::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& VResponse::data() const {
  // @@protoc_insertion_point(field_get:VResponse.data)
  return *data_;
}
inline void VResponse::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:VResponse.data)
}
inline void VResponse::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:VResponse.data)
}
inline void VResponse::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:VResponse.data)
}
inline ::std::string* VResponse::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:VResponse.data)
  return data_;
}
inline ::std::string* VResponse::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VResponse::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:VResponse.data)
}

// -------------------------------------------------------------------

// VAll

// repeated .VResponse response = 1;
inline int VAll::response_size() const {
  return response_.size();
}
inline void VAll::clear_response() {
  response_.Clear();
}
inline const ::VResponse& VAll::response(int index) const {
  // @@protoc_insertion_point(field_get:VAll.response)
  return response_.Get(index);
}
inline ::VResponse* VAll::mutable_response(int index) {
  // @@protoc_insertion_point(field_mutable:VAll.response)
  return response_.Mutable(index);
}
inline ::VResponse* VAll::add_response() {
  // @@protoc_insertion_point(field_add:VAll.response)
  return response_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::VResponse >&
VAll::response() const {
  // @@protoc_insertion_point(field_list:VAll.response)
  return response_;
}
inline ::google::protobuf::RepeatedPtrField< ::VResponse >*
VAll::mutable_response() {
  // @@protoc_insertion_point(field_mutable_list:VAll.response)
  return &response_;
}

// -------------------------------------------------------------------

// VReqFeature

// required int32 i_layer = 1;
inline bool VReqFeature::has_i_layer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VReqFeature::set_has_i_layer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VReqFeature::clear_has_i_layer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VReqFeature::clear_i_layer() {
  i_layer_ = 0;
  clear_has_i_layer();
}
inline ::google::protobuf::int32 VReqFeature::i_layer() const {
  // @@protoc_insertion_point(field_get:VReqFeature.i_layer)
  return i_layer_;
}
inline void VReqFeature::set_i_layer(::google::protobuf::int32 value) {
  set_has_i_layer();
  i_layer_ = value;
  // @@protoc_insertion_point(field_set:VReqFeature.i_layer)
}

// required int32 i_image = 2;
inline bool VReqFeature::has_i_image() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VReqFeature::set_has_i_image() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VReqFeature::clear_has_i_image() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VReqFeature::clear_i_image() {
  i_image_ = 0;
  clear_has_i_image();
}
inline ::google::protobuf::int32 VReqFeature::i_image() const {
  // @@protoc_insertion_point(field_get:VReqFeature.i_image)
  return i_image_;
}
inline void VReqFeature::set_i_image(::google::protobuf::int32 value) {
  set_has_i_image();
  i_image_ = value;
  // @@protoc_insertion_point(field_set:VReqFeature.i_image)
}

// optional bool diff = 3 [default = false];
inline bool VReqFeature::has_diff() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VReqFeature::set_has_diff() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VReqFeature::clear_has_diff() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VReqFeature::clear_diff() {
  diff_ = false;
  clear_has_diff();
}
inline bool VReqFeature::diff() const {
  // @@protoc_insertion_point(field_get:VReqFeature.diff)
  return diff_;
}
inline void VReqFeature::set_diff(bool value) {
  set_has_diff();
  diff_ = value;
  // @@protoc_insertion_point(field_set:VReqFeature.diff)
}

// -------------------------------------------------------------------

// VReqWeight

// required int32 index = 1;
inline bool VReqWeight::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VReqWeight::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VReqWeight::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VReqWeight::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 VReqWeight::index() const {
  // @@protoc_insertion_point(field_get:VReqWeight.index)
  return index_;
}
inline void VReqWeight::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:VReqWeight.index)
}

// optional bool diff = 2 [default = false];
inline bool VReqWeight::has_diff() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VReqWeight::set_has_diff() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VReqWeight::clear_has_diff() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VReqWeight::clear_diff() {
  diff_ = false;
  clear_has_diff();
}
inline bool VReqWeight::diff() const {
  // @@protoc_insertion_point(field_get:VReqWeight.diff)
  return diff_;
}
inline void VReqWeight::set_diff(bool value) {
  set_has_diff();
  diff_ = value;
  // @@protoc_insertion_point(field_set:VReqWeight.diff)
}

// -------------------------------------------------------------------

// VState

// optional bool auto = 1 [default = true];
inline bool VState::has_auto_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VState::set_has_auto_() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VState::clear_has_auto_() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VState::clear_auto_() {
  auto__ = true;
  clear_has_auto_();
}
inline bool VState::auto_() const {
  // @@protoc_insertion_point(field_get:VState.auto)
  return auto__;
}
inline void VState::set_auto_(bool value) {
  set_has_auto_();
  auto__ = value;
  // @@protoc_insertion_point(field_set:VState.auto)
}

// optional int32 input = 2 [default = -1];
inline bool VState::has_input() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VState::set_has_input() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VState::clear_has_input() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VState::clear_input() {
  input_ = -1;
  clear_has_input();
}
inline ::google::protobuf::int32 VState::input() const {
  // @@protoc_insertion_point(field_get:VState.input)
  return input_;
}
inline void VState::set_input(::google::protobuf::int32 value) {
  set_has_input();
  input_ = value;
  // @@protoc_insertion_point(field_set:VState.input)
}

// optional .VReqFeature map = 3;
inline bool VState::has_map() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VState::set_has_map() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VState::clear_has_map() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VState::clear_map() {
  if (map_ != NULL) map_->::VReqFeature::Clear();
  clear_has_map();
}
inline const ::VReqFeature& VState::map() const {
  // @@protoc_insertion_point(field_get:VState.map)
  return map_ != NULL ? *map_ : *default_instance_->map_;
}
inline ::VReqFeature* VState::mutable_map() {
  set_has_map();
  if (map_ == NULL) map_ = new ::VReqFeature;
  // @@protoc_insertion_point(field_mutable:VState.map)
  return map_;
}
inline ::VReqFeature* VState::release_map() {
  clear_has_map();
  ::VReqFeature* temp = map_;
  map_ = NULL;
  return temp;
}
inline void VState::set_allocated_map(::VReqFeature* map) {
  delete map_;
  map_ = map;
  if (map) {
    set_has_map();
  } else {
    clear_has_map();
  }
  // @@protoc_insertion_point(field_set_allocated:VState.map)
}

// optional .VReqDeconv deconv = 4;
inline bool VState::has_deconv() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VState::set_has_deconv() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VState::clear_has_deconv() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VState::clear_deconv() {
  if (deconv_ != NULL) deconv_->::VReqDeconv::Clear();
  clear_has_deconv();
}
inline const ::VReqDeconv& VState::deconv() const {
  // @@protoc_insertion_point(field_get:VState.deconv)
  return deconv_ != NULL ? *deconv_ : *default_instance_->deconv_;
}
inline ::VReqDeconv* VState::mutable_deconv() {
  set_has_deconv();
  if (deconv_ == NULL) deconv_ = new ::VReqDeconv;
  // @@protoc_insertion_point(field_mutable:VState.deconv)
  return deconv_;
}
inline ::VReqDeconv* VState::release_deconv() {
  clear_has_deconv();
  ::VReqDeconv* temp = deconv_;
  deconv_ = NULL;
  return temp;
}
inline void VState::set_allocated_deconv(::VReqDeconv* deconv) {
  delete deconv_;
  deconv_ = deconv;
  if (deconv) {
    set_has_deconv();
  } else {
    clear_has_deconv();
  }
  // @@protoc_insertion_point(field_set_allocated:VState.deconv)
}

// optional .VReqWeight weight = 5;
inline bool VState::has_weight() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VState::set_has_weight() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VState::clear_has_weight() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VState::clear_weight() {
  if (weight_ != NULL) weight_->::VReqWeight::Clear();
  clear_has_weight();
}
inline const ::VReqWeight& VState::weight() const {
  // @@protoc_insertion_point(field_get:VState.weight)
  return weight_ != NULL ? *weight_ : *default_instance_->weight_;
}
inline ::VReqWeight* VState::mutable_weight() {
  set_has_weight();
  if (weight_ == NULL) weight_ = new ::VReqWeight;
  // @@protoc_insertion_point(field_mutable:VState.weight)
  return weight_;
}
inline ::VReqWeight* VState::release_weight() {
  clear_has_weight();
  ::VReqWeight* temp = weight_;
  weight_ = NULL;
  return temp;
}
inline void VState::set_allocated_weight(::VReqWeight* weight) {
  delete weight_;
  weight_ = weight;
  if (weight) {
    set_has_weight();
  } else {
    clear_has_weight();
  }
  // @@protoc_insertion_point(field_set_allocated:VState.weight)
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::DetectInput_Format> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DetectInput_Format>() {
  return ::DetectInput_Format_descriptor();
}
template <> struct is_proto_enum< ::CommuParameter_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CommuParameter_Type>() {
  return ::CommuParameter_Type_descriptor();
}
template <> struct is_proto_enum< ::VResponse_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::VResponse_Type>() {
  return ::VResponse_Type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_zoson_2eproto__INCLUDED
